var we = Object.defineProperty;
var a = (s, e) => we(s, "name", { value: e, configurable: !0 });
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const W = globalThis, X = W.ShadowRoot && (W.ShadyCSS === void 0 || W.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, ee = Symbol(), re = /* @__PURE__ */ new WeakMap();
let me = class {
  static {
    a(this, "n");
  }
  constructor(e, t, i) {
    if (this._$cssResult$ = !0, i !== ee) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = e, this.t = t;
  }
  get styleSheet() {
    let e = this.o;
    const t = this.t;
    if (X && e === void 0) {
      const i = t !== void 0 && t.length === 1;
      i && (e = re.get(t)), e === void 0 && ((this.o = e = new CSSStyleSheet()).replaceSync(this.cssText), i && re.set(t, e));
    }
    return e;
  }
  toString() {
    return this.cssText;
  }
};
const _e = /* @__PURE__ */ a((s) => new me(typeof s == "string" ? s : s + "", void 0, ee), "r$4"), Z = /* @__PURE__ */ a((s, ...e) => {
  const t = s.length === 1 ? s[0] : e.reduce((i, o, r) => i + ((n) => {
    if (n._$cssResult$ === !0) return n.cssText;
    if (typeof n == "number") return n;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + n + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(o) + s[r + 1], s[0]);
  return new me(t, s, ee);
}, "i$3"), xe = /* @__PURE__ */ a((s, e) => {
  if (X) s.adoptedStyleSheets = e.map((t) => t instanceof CSSStyleSheet ? t : t.styleSheet);
  else for (const t of e) {
    const i = document.createElement("style"), o = W.litNonce;
    o !== void 0 && i.setAttribute("nonce", o), i.textContent = t.cssText, s.appendChild(i);
  }
}, "S$1"), ne = X ? (s) => s : (s) => s instanceof CSSStyleSheet ? ((e) => {
  let t = "";
  for (const i of e.cssRules) t += i.cssText;
  return _e(t);
})(s) : s;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: Ae, defineProperty: Ce, getOwnPropertyDescriptor: Ee, getOwnPropertyNames: Se, getOwnPropertySymbols: De, getPrototypeOf: Pe } = Object, J = globalThis, ae = J.trustedTypes, Te = ae ? ae.emptyScript : "", Oe = J.reactiveElementPolyfillSupport, I = /* @__PURE__ */ a((s, e) => s, "d$1"), q = { toAttribute(s, e) {
  switch (e) {
    case Boolean:
      s = s ? Te : null;
      break;
    case Object:
    case Array:
      s = s == null ? s : JSON.stringify(s);
  }
  return s;
}, fromAttribute(s, e) {
  let t = s;
  switch (e) {
    case Boolean:
      t = s !== null;
      break;
    case Number:
      t = s === null ? null : Number(s);
      break;
    case Object:
    case Array:
      try {
        t = JSON.parse(s);
      } catch {
        t = null;
      }
  }
  return t;
} }, te = /* @__PURE__ */ a((s, e) => !Ae(s, e), "f$1"), le = { attribute: !0, type: String, converter: q, reflect: !1, useDefault: !1, hasChanged: te };
Symbol.metadata ??= Symbol("metadata"), J.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
let M = class extends HTMLElement {
  static {
    a(this, "y");
  }
  static addInitializer(e) {
    this._$Ei(), (this.l ??= []).push(e);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(e, t = le) {
    if (t.state && (t.attribute = !1), this._$Ei(), this.prototype.hasOwnProperty(e) && ((t = Object.create(t)).wrapped = !0), this.elementProperties.set(e, t), !t.noAccessor) {
      const i = Symbol(), o = this.getPropertyDescriptor(e, i, t);
      o !== void 0 && Ce(this.prototype, e, o);
    }
  }
  static getPropertyDescriptor(e, t, i) {
    const { get: o, set: r } = Ee(this.prototype, e) ?? { get() {
      return this[t];
    }, set(n) {
      this[t] = n;
    } };
    return { get: o, set(n) {
      const d = o?.call(this);
      r?.call(this, n), this.requestUpdate(e, d, i);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(e) {
    return this.elementProperties.get(e) ?? le;
  }
  static _$Ei() {
    if (this.hasOwnProperty(I("elementProperties"))) return;
    const e = Pe(this);
    e.finalize(), e.l !== void 0 && (this.l = [...e.l]), this.elementProperties = new Map(e.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(I("finalized"))) return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(I("properties"))) {
      const t = this.properties, i = [...Se(t), ...De(t)];
      for (const o of i) this.createProperty(o, t[o]);
    }
    const e = this[Symbol.metadata];
    if (e !== null) {
      const t = litPropertyMetadata.get(e);
      if (t !== void 0) for (const [i, o] of t) this.elementProperties.set(i, o);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t, i] of this.elementProperties) {
      const o = this._$Eu(t, i);
      o !== void 0 && this._$Eh.set(o, t);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(e) {
    const t = [];
    if (Array.isArray(e)) {
      const i = new Set(e.flat(1 / 0).reverse());
      for (const o of i) t.unshift(ne(o));
    } else e !== void 0 && t.push(ne(e));
    return t;
  }
  static _$Eu(e, t) {
    const i = t.attribute;
    return i === !1 ? void 0 : typeof i == "string" ? i : typeof e == "string" ? e.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise((e) => this.enableUpdating = e), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((e) => e(this));
  }
  addController(e) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(e), this.renderRoot !== void 0 && this.isConnected && e.hostConnected?.();
  }
  removeController(e) {
    this._$EO?.delete(e);
  }
  _$E_() {
    const e = /* @__PURE__ */ new Map(), t = this.constructor.elementProperties;
    for (const i of t.keys()) this.hasOwnProperty(i) && (e.set(i, this[i]), delete this[i]);
    e.size > 0 && (this._$Ep = e);
  }
  createRenderRoot() {
    const e = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return xe(e, this.constructor.elementStyles), e;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(!0), this._$EO?.forEach((e) => e.hostConnected?.());
  }
  enableUpdating(e) {
  }
  disconnectedCallback() {
    this._$EO?.forEach((e) => e.hostDisconnected?.());
  }
  attributeChangedCallback(e, t, i) {
    this._$AK(e, i);
  }
  _$ET(e, t) {
    const i = this.constructor.elementProperties.get(e), o = this.constructor._$Eu(e, i);
    if (o !== void 0 && i.reflect === !0) {
      const r = (i.converter?.toAttribute !== void 0 ? i.converter : q).toAttribute(t, i.type);
      this._$Em = e, r == null ? this.removeAttribute(o) : this.setAttribute(o, r), this._$Em = null;
    }
  }
  _$AK(e, t) {
    const i = this.constructor, o = i._$Eh.get(e);
    if (o !== void 0 && this._$Em !== o) {
      const r = i.getPropertyOptions(o), n = typeof r.converter == "function" ? { fromAttribute: r.converter } : r.converter?.fromAttribute !== void 0 ? r.converter : q;
      this._$Em = o;
      const d = n.fromAttribute(t, r.type);
      this[o] = d ?? this._$Ej?.get(o) ?? d, this._$Em = null;
    }
  }
  requestUpdate(e, t, i, o = !1, r) {
    if (e !== void 0) {
      const n = this.constructor;
      if (o === !1 && (r = this[e]), i ??= n.getPropertyOptions(e), !((i.hasChanged ?? te)(r, t) || i.useDefault && i.reflect && r === this._$Ej?.get(e) && !this.hasAttribute(n._$Eu(e, i)))) return;
      this.C(e, t, i);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$EP());
  }
  C(e, t, { useDefault: i, reflect: o, wrapped: r }, n) {
    i && !(this._$Ej ??= /* @__PURE__ */ new Map()).has(e) && (this._$Ej.set(e, n ?? t ?? this[e]), r !== !0 || n !== void 0) || (this._$AL.has(e) || (this.hasUpdated || i || (t = void 0), this._$AL.set(e, t)), o === !0 && this._$Em !== e && (this._$Eq ??= /* @__PURE__ */ new Set()).add(e));
  }
  async _$EP() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (t) {
      Promise.reject(t);
    }
    const e = this.scheduleUpdate();
    return e != null && await e, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [o, r] of this._$Ep) this[o] = r;
        this._$Ep = void 0;
      }
      const i = this.constructor.elementProperties;
      if (i.size > 0) for (const [o, r] of i) {
        const { wrapped: n } = r, d = this[o];
        n !== !0 || this._$AL.has(o) || d === void 0 || this.C(o, void 0, r, d);
      }
    }
    let e = !1;
    const t = this._$AL;
    try {
      e = this.shouldUpdate(t), e ? (this.willUpdate(t), this._$EO?.forEach((i) => i.hostUpdate?.()), this.update(t)) : this._$EM();
    } catch (i) {
      throw e = !1, this._$EM(), i;
    }
    e && this._$AE(t);
  }
  willUpdate(e) {
  }
  _$AE(e) {
    this._$EO?.forEach((t) => t.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(e)), this.updated(e);
  }
  _$EM() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(e) {
    return !0;
  }
  update(e) {
    this._$Eq &&= this._$Eq.forEach((t) => this._$ET(t, this[t])), this._$EM();
  }
  updated(e) {
  }
  firstUpdated(e) {
  }
};
M.elementStyles = [], M.shadowRootOptions = { mode: "open" }, M[I("elementProperties")] = /* @__PURE__ */ new Map(), M[I("finalized")] = /* @__PURE__ */ new Map(), Oe?.({ ReactiveElement: M }), (J.reactiveElementVersions ??= []).push("2.1.2");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const se = globalThis, he = /* @__PURE__ */ a((s) => s, "i$1"), F = se.trustedTypes, ce = F ? F.createPolicy("lit-html", { createHTML: /* @__PURE__ */ a((s) => s, "createHTML") }) : void 0, ge = "$lit$", S = `lit$${Math.random().toFixed(9).slice(2)}$`, $e = "?" + S, ze = `<${$e}>`, O = document, H = /* @__PURE__ */ a(() => O.createComment(""), "c"), R = /* @__PURE__ */ a((s) => s === null || typeof s != "object" && typeof s != "function", "a"), ie = Array.isArray, Me = /* @__PURE__ */ a((s) => ie(s) || typeof s?.[Symbol.iterator] == "function", "d"), Q = `[ 	
\f\r]`, U = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, de = /-->/g, pe = />/g, P = RegExp(`>|${Q}(?:([^\\s"'>=/]+)(${Q}*=${Q}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), ue = /'/g, fe = /"/g, ve = /^(?:script|style|textarea|title)$/i, Le = /* @__PURE__ */ a((s) => (e, ...t) => ({ _$litType$: s, strings: e, values: t }), "x"), l = Le(1), L = Symbol.for("lit-noChange"), c = Symbol.for("lit-nothing"), be = /* @__PURE__ */ new WeakMap(), T = O.createTreeWalker(O, 129);
function ye(s, e) {
  if (!ie(s) || !s.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return ce !== void 0 ? ce.createHTML(e) : e;
}
a(ye, "V");
const Ne = /* @__PURE__ */ a((s, e) => {
  const t = s.length - 1, i = [];
  let o, r = e === 2 ? "<svg>" : e === 3 ? "<math>" : "", n = U;
  for (let d = 0; d < t; d++) {
    const h = s[d];
    let f, b, u = -1, _ = 0;
    for (; _ < h.length && (n.lastIndex = _, b = n.exec(h), b !== null); ) _ = n.lastIndex, n === U ? b[1] === "!--" ? n = de : b[1] !== void 0 ? n = pe : b[2] !== void 0 ? (ve.test(b[2]) && (o = RegExp("</" + b[2], "g")), n = P) : b[3] !== void 0 && (n = P) : n === P ? b[0] === ">" ? (n = o ?? U, u = -1) : b[1] === void 0 ? u = -2 : (u = n.lastIndex - b[2].length, f = b[1], n = b[3] === void 0 ? P : b[3] === '"' ? fe : ue) : n === fe || n === ue ? n = P : n === de || n === pe ? n = U : (n = P, o = void 0);
    const E = n === P && s[d + 1].startsWith("/>") ? " " : "";
    r += n === U ? h + ze : u >= 0 ? (i.push(f), h.slice(0, u) + ge + h.slice(u) + S + E) : h + S + (u === -2 ? d : E);
  }
  return [ye(s, r + (s[t] || "<?>") + (e === 2 ? "</svg>" : e === 3 ? "</math>" : "")), i];
}, "N");
class j {
  static {
    a(this, "S");
  }
  constructor({ strings: e, _$litType$: t }, i) {
    let o;
    this.parts = [];
    let r = 0, n = 0;
    const d = e.length - 1, h = this.parts, [f, b] = Ne(e, t);
    if (this.el = j.createElement(f, i), T.currentNode = this.el.content, t === 2 || t === 3) {
      const u = this.el.content.firstChild;
      u.replaceWith(...u.childNodes);
    }
    for (; (o = T.nextNode()) !== null && h.length < d; ) {
      if (o.nodeType === 1) {
        if (o.hasAttributes()) for (const u of o.getAttributeNames()) if (u.endsWith(ge)) {
          const _ = b[n++], E = o.getAttribute(u).split(S), V = /([.?@])?(.*)/.exec(_);
          h.push({ type: 1, index: r, name: V[2], strings: E, ctor: V[1] === "." ? Ie : V[1] === "?" ? ke : V[1] === "@" ? He : Y }), o.removeAttribute(u);
        } else u.startsWith(S) && (h.push({ type: 6, index: r }), o.removeAttribute(u));
        if (ve.test(o.tagName)) {
          const u = o.textContent.split(S), _ = u.length - 1;
          if (_ > 0) {
            o.textContent = F ? F.emptyScript : "";
            for (let E = 0; E < _; E++) o.append(u[E], H()), T.nextNode(), h.push({ type: 2, index: ++r });
            o.append(u[_], H());
          }
        }
      } else if (o.nodeType === 8) if (o.data === $e) h.push({ type: 2, index: r });
      else {
        let u = -1;
        for (; (u = o.data.indexOf(S, u + 1)) !== -1; ) h.push({ type: 7, index: r }), u += S.length - 1;
      }
      r++;
    }
  }
  static createElement(e, t) {
    const i = O.createElement("template");
    return i.innerHTML = e, i;
  }
}
function N(s, e, t = s, i) {
  if (e === L) return e;
  let o = i !== void 0 ? t._$Co?.[i] : t._$Cl;
  const r = R(e) ? void 0 : e._$litDirective$;
  return o?.constructor !== r && (o?._$AO?.(!1), r === void 0 ? o = void 0 : (o = new r(s), o._$AT(s, t, i)), i !== void 0 ? (t._$Co ??= [])[i] = o : t._$Cl = o), o !== void 0 && (e = N(s, o._$AS(s, e.values), o, i)), e;
}
a(N, "M");
class Ue {
  static {
    a(this, "R");
  }
  constructor(e, t) {
    this._$AV = [], this._$AN = void 0, this._$AD = e, this._$AM = t;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(e) {
    const { el: { content: t }, parts: i } = this._$AD, o = (e?.creationScope ?? O).importNode(t, !0);
    T.currentNode = o;
    let r = T.nextNode(), n = 0, d = 0, h = i[0];
    for (; h !== void 0; ) {
      if (n === h.index) {
        let f;
        h.type === 2 ? f = new B(r, r.nextSibling, this, e) : h.type === 1 ? f = new h.ctor(r, h.name, h.strings, this, e) : h.type === 6 && (f = new Re(r, this, e)), this._$AV.push(f), h = i[++d];
      }
      n !== h?.index && (r = T.nextNode(), n++);
    }
    return T.currentNode = O, o;
  }
  p(e) {
    let t = 0;
    for (const i of this._$AV) i !== void 0 && (i.strings !== void 0 ? (i._$AI(e, i, t), t += i.strings.length - 2) : i._$AI(e[t])), t++;
  }
}
class B {
  static {
    a(this, "k");
  }
  get _$AU() {
    return this._$AM?._$AU ?? this._$Cv;
  }
  constructor(e, t, i, o) {
    this.type = 2, this._$AH = c, this._$AN = void 0, this._$AA = e, this._$AB = t, this._$AM = i, this.options = o, this._$Cv = o?.isConnected ?? !0;
  }
  get parentNode() {
    let e = this._$AA.parentNode;
    const t = this._$AM;
    return t !== void 0 && e?.nodeType === 11 && (e = t.parentNode), e;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(e, t = this) {
    e = N(this, e, t), R(e) ? e === c || e == null || e === "" ? (this._$AH !== c && this._$AR(), this._$AH = c) : e !== this._$AH && e !== L && this._(e) : e._$litType$ !== void 0 ? this.$(e) : e.nodeType !== void 0 ? this.T(e) : Me(e) ? this.k(e) : this._(e);
  }
  O(e) {
    return this._$AA.parentNode.insertBefore(e, this._$AB);
  }
  T(e) {
    this._$AH !== e && (this._$AR(), this._$AH = this.O(e));
  }
  _(e) {
    this._$AH !== c && R(this._$AH) ? this._$AA.nextSibling.data = e : this.T(O.createTextNode(e)), this._$AH = e;
  }
  $(e) {
    const { values: t, _$litType$: i } = e, o = typeof i == "number" ? this._$AC(e) : (i.el === void 0 && (i.el = j.createElement(ye(i.h, i.h[0]), this.options)), i);
    if (this._$AH?._$AD === o) this._$AH.p(t);
    else {
      const r = new Ue(o, this), n = r.u(this.options);
      r.p(t), this.T(n), this._$AH = r;
    }
  }
  _$AC(e) {
    let t = be.get(e.strings);
    return t === void 0 && be.set(e.strings, t = new j(e)), t;
  }
  k(e) {
    ie(this._$AH) || (this._$AH = [], this._$AR());
    const t = this._$AH;
    let i, o = 0;
    for (const r of e) o === t.length ? t.push(i = new B(this.O(H()), this.O(H()), this, this.options)) : i = t[o], i._$AI(r), o++;
    o < t.length && (this._$AR(i && i._$AB.nextSibling, o), t.length = o);
  }
  _$AR(e = this._$AA.nextSibling, t) {
    for (this._$AP?.(!1, !0, t); e !== this._$AB; ) {
      const i = he(e).nextSibling;
      he(e).remove(), e = i;
    }
  }
  setConnected(e) {
    this._$AM === void 0 && (this._$Cv = e, this._$AP?.(e));
  }
}
class Y {
  static {
    a(this, "H");
  }
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(e, t, i, o, r) {
    this.type = 1, this._$AH = c, this._$AN = void 0, this.element = e, this.name = t, this._$AM = o, this.options = r, i.length > 2 || i[0] !== "" || i[1] !== "" ? (this._$AH = Array(i.length - 1).fill(new String()), this.strings = i) : this._$AH = c;
  }
  _$AI(e, t = this, i, o) {
    const r = this.strings;
    let n = !1;
    if (r === void 0) e = N(this, e, t, 0), n = !R(e) || e !== this._$AH && e !== L, n && (this._$AH = e);
    else {
      const d = e;
      let h, f;
      for (e = r[0], h = 0; h < r.length - 1; h++) f = N(this, d[i + h], t, h), f === L && (f = this._$AH[h]), n ||= !R(f) || f !== this._$AH[h], f === c ? e = c : e !== c && (e += (f ?? "") + r[h + 1]), this._$AH[h] = f;
    }
    n && !o && this.j(e);
  }
  j(e) {
    e === c ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, e ?? "");
  }
}
class Ie extends Y {
  static {
    a(this, "I");
  }
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(e) {
    this.element[this.name] = e === c ? void 0 : e;
  }
}
class ke extends Y {
  static {
    a(this, "L");
  }
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(e) {
    this.element.toggleAttribute(this.name, !!e && e !== c);
  }
}
class He extends Y {
  static {
    a(this, "z");
  }
  constructor(e, t, i, o, r) {
    super(e, t, i, o, r), this.type = 5;
  }
  _$AI(e, t = this) {
    if ((e = N(this, e, t, 0) ?? c) === L) return;
    const i = this._$AH, o = e === c && i !== c || e.capture !== i.capture || e.once !== i.once || e.passive !== i.passive, r = e !== c && (i === c || o);
    o && this.element.removeEventListener(this.name, this, i), r && this.element.addEventListener(this.name, this, e), this._$AH = e;
  }
  handleEvent(e) {
    typeof this._$AH == "function" ? this._$AH.call(this.options?.host ?? this.element, e) : this._$AH.handleEvent(e);
  }
}
class Re {
  static {
    a(this, "Z");
  }
  constructor(e, t, i) {
    this.element = e, this.type = 6, this._$AN = void 0, this._$AM = t, this.options = i;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(e) {
    N(this, e);
  }
}
const je = se.litHtmlPolyfillSupport;
je?.(j, B), (se.litHtmlVersions ??= []).push("3.3.2");
const Be = /* @__PURE__ */ a((s, e, t) => {
  const i = t?.renderBefore ?? e;
  let o = i._$litPart$;
  if (o === void 0) {
    const r = t?.renderBefore ?? null;
    i._$litPart$ = o = new B(e.insertBefore(H(), r), r, void 0, t ?? {});
  }
  return o._$AI(s), o;
}, "D");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const oe = globalThis;
class k extends M {
  static {
    a(this, "i");
  }
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    const e = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= e.firstChild, e;
  }
  update(e) {
    const t = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(e), this._$Do = Be(t, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this._$Do?.setConnected(!0);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._$Do?.setConnected(!1);
  }
  render() {
    return L;
  }
}
k._$litElement$ = !0, k.finalized = !0, oe.litElementHydrateSupport?.({ LitElement: k });
const Ve = oe.litElementPolyfillSupport;
Ve?.({ LitElement: k });
(oe.litElementVersions ??= []).push("4.2.2");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const G = /* @__PURE__ */ a((s) => (e, t) => {
  t !== void 0 ? t.addInitializer(() => {
    customElements.define(s, e);
  }) : customElements.define(s, e);
}, "t");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const We = { attribute: !0, type: String, converter: q, reflect: !1, hasChanged: te }, qe = /* @__PURE__ */ a((s = We, e, t) => {
  const { kind: i, metadata: o } = t;
  let r = globalThis.litPropertyMetadata.get(o);
  if (r === void 0 && globalThis.litPropertyMetadata.set(o, r = /* @__PURE__ */ new Map()), i === "setter" && ((s = Object.create(s)).wrapped = !0), r.set(t.name, s), i === "accessor") {
    const { name: n } = t;
    return { set(d) {
      const h = e.get.call(this);
      e.set.call(this, d), this.requestUpdate(n, h, s, !0, d);
    }, init(d) {
      return d !== void 0 && this.C(n, void 0, s, d), d;
    } };
  }
  if (i === "setter") {
    const { name: n } = t;
    return function(d) {
      const h = this[n];
      e.call(this, d), this.requestUpdate(n, h, s, !0, d);
    };
  }
  throw Error("Unsupported decorator location: " + i);
}, "r$1");
function p(s) {
  return (e, t) => typeof t == "object" ? qe(s, e, t) : ((i, o, r) => {
    const n = o.hasOwnProperty(r);
    return o.constructor.createProperty(r, i), n ? Object.getOwnPropertyDescriptor(o, r) : void 0;
  })(s, e, t);
}
a(p, "n");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function y(s) {
  return p({ ...s, state: !0, attribute: !1 });
}
a(y, "r");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Fe = /* @__PURE__ */ a((s, e, t) => (t.configurable = !0, t.enumerable = !0, Reflect.decorate && typeof e != "object" && Object.defineProperty(s, e, t), t), "e$1");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function Ke(s, e) {
  return (t, i, o) => {
    const r = /* @__PURE__ */ a((n) => n.renderRoot?.querySelector(s) ?? null, "o");
    return Fe(t, i, { get() {
      return r(this);
    } });
  };
}
a(Ke, "e");
const K = /* @__PURE__ */ new Map(), Ze = 300 * 1e3;
async function Je(s) {
  const e = K.get(s);
  if (e && Date.now() - e.timestamp < Ze)
    return e.data;
  const t = await fetch(s);
  if (!t.ok)
    throw new Error(`Failed to fetch vocabulary: ${t.status} ${t.statusText}`);
  const i = await t.json();
  if (!i.concepts || !Array.isArray(i.concepts))
    throw new Error("Invalid vocabulary format: missing concepts array");
  return K.set(s, { data: i, timestamp: Date.now() }), i;
}
a(Je, "fetchVocab");
function ct(s) {
  s ? K.delete(s) : K.clear();
}
a(ct, "clearCache");
function Ye() {
  const s = document.querySelectorAll('script[src*="prez-vocab"]');
  if (s.length > 0) {
    const e = s[s.length - 1].src, t = new URL(e), i = t.pathname.split("/");
    return i.pop(), i.pop(), t.pathname = i.join("/") || "/", t.origin + t.pathname.replace(/\/$/, "");
  }
  return null;
}
a(Ye, "detectBaseUrl");
function Ge(s, e, t) {
  if (e) return e;
  if (!s) return null;
  const i = t || Ye();
  return i ? `${i}/export/vocabs/${s}/${s}.json` : null;
}
a(Ge, "resolveVocabUrl");
var Qe = Object.defineProperty, A = /* @__PURE__ */ a((s, e, t, i) => {
  for (var o = void 0, r = s.length - 1, n; r >= 0; r--)
    (n = s[r]) && (o = n(e, t, o) || o);
  return o && Qe(e, t, o), o;
}, "__decorateClass$4");
class m extends k {
  static {
    a(this, "PrezVocabBase");
  }
  constructor() {
    super(...arguments), this.vocab = null, this.vocabUrl = null, this.baseUrl = null, this.disabled = !1, this.lang = "en", this.loading = !1, this.error = null, this.vocabData = null, this.conceptMap = /* @__PURE__ */ new Map();
  }
  updated(e) {
    super.updated(e), (e.has("vocab") || e.has("vocabUrl") || e.has("baseUrl")) && this.loadVocab();
  }
  async loadVocab() {
    const e = Ge(this.vocab, this.vocabUrl, this.baseUrl);
    if (!e) {
      this.vocabData = null, this.conceptMap = /* @__PURE__ */ new Map();
      return;
    }
    this.loading = !0, this.error = null;
    try {
      this.vocabData = await Je(e), this.conceptMap = new Map(this.vocabData.concepts.map((t) => [t.iri, t])), this.dispatchEvent(new CustomEvent("prez-load", {
        bubbles: !0,
        composed: !0,
        detail: {
          vocab: this.vocab,
          url: e,
          conceptCount: this.vocabData.concepts.length
        }
      }));
    } catch (t) {
      this.error = t instanceof Error ? t.message : "Failed to load vocabulary", this.vocabData = null, this.conceptMap = /* @__PURE__ */ new Map(), this.dispatchEvent(new CustomEvent("prez-error", {
        bubbles: !0,
        composed: !0,
        detail: {
          vocab: this.vocab,
          url: e,
          error: this.error
        }
      }));
    } finally {
      this.loading = !1;
    }
  }
  /** Emit change event */
  emitChange(e) {
    this.dispatchEvent(new CustomEvent("prez-change", {
      bubbles: !0,
      composed: !0,
      detail: {
        value: e,
        vocab: this.vocab,
        concepts: Array.isArray(e) ? e.map((t) => this.conceptMap.get(t)).filter(Boolean) : this.conceptMap.get(e) || null
      }
    }));
  }
  /** Get label for a concept IRI */
  getConceptLabel(e) {
    return this.conceptMap.get(e)?.label || e.split(/[#/]/).pop() || e;
  }
}
A([
  p({ type: String })
], m.prototype, "vocab");
A([
  p({ type: String, attribute: "vocab-url" })
], m.prototype, "vocabUrl");
A([
  p({ type: String, attribute: "base-url" })
], m.prototype, "baseUrl");
A([
  p({ type: Boolean, reflect: !0 })
], m.prototype, "disabled");
A([
  p({ type: String })
], m.prototype, "lang");
A([
  y()
], m.prototype, "loading");
A([
  y()
], m.prototype, "error");
A([
  y()
], m.prototype, "vocabData");
A([
  y()
], m.prototype, "conceptMap");
var Xe = Object.defineProperty, et = Object.getOwnPropertyDescriptor, C = /* @__PURE__ */ a((s, e, t, i) => {
  for (var o = i > 1 ? void 0 : i ? et(e, t) : e, r = s.length - 1, n; r >= 0; r--)
    (n = s[r]) && (o = (i ? n(e, t, o) : n(o)) || o);
  return i && o && Xe(e, t, o), o;
}, "__decorateClass$3");
let $ = class extends m {
  static {
    a(this, "PrezVocabSelect");
  }
  constructor() {
    super(...arguments), this.multiple = !1, this.searchable = !1, this.placeholder = "Select a concept...", this.value = null, this.values = [], this.maxSelections = null, this.showIri = !1, this.filterText = "";
  }
  handleChange(s) {
    const e = s.target;
    if (this.multiple) {
      const t = Array.from(e.selectedOptions).map((i) => i.value);
      this.values = t, this.emitChange(t);
    } else {
      const t = e.value || null;
      this.value = t, this.emitChange(t || "");
    }
  }
  get filteredConcepts() {
    if (!this.vocabData?.concepts) return [];
    let s = this.vocabData.concepts;
    if (this.searchable && this.filterText) {
      const e = this.filterText.toLowerCase();
      s = s.filter(
        (t) => t.label.toLowerCase().includes(e) || t.notation?.toLowerCase().includes(e) || t.altLabels?.some((i) => i.toLowerCase().includes(e))
      );
    }
    return [...s].sort((e, t) => e.label.localeCompare(t.label));
  }
  render() {
    if (this.loading)
      return l`<div class="loading">Loading vocabulary...</div>`;
    if (this.error)
      return l`<div class="error">${this.error}</div>`;
    if (!this.vocabData)
      return l`<div class="loading">No vocabulary specified</div>`;
    const s = this.filteredConcepts;
    return l`
      <div class="select-wrapper">
        <select
          ?multiple=${this.multiple}
          ?disabled=${this.disabled}
          @change=${this.handleChange}
          aria-label=${this.vocabData.label || "Vocabulary select"}
        >
          ${this.multiple ? c : l`
            <option value="" ?selected=${!this.value}>${this.placeholder}</option>
          `}
          ${s.map((e) => {
      const t = this.multiple ? this.values.includes(e.iri) : this.value === e.iri, i = this.showIri ? `${e.label} (${e.iri})` : e.notation ? `${e.notation} - ${e.label}` : e.label;
      return l`
              <option value=${e.iri} ?selected=${t}>
                ${i}
              </option>
            `;
    })}
        </select>
        ${this.multiple ? c : l`
          <span class="chevron">
            <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
              <path d="M4.427 6.427l3.396 3.396a.25.25 0 00.354 0l3.396-3.396A.25.25 0 0011.396 6H4.604a.25.25 0 00-.177.427z"/>
            </svg>
          </span>
        `}
      </div>
      ${this.multiple && this.values.length > 0 ? l`
        <div class="selection-count">
          ${this.values.length} selected${this.maxSelections ? ` (max ${this.maxSelections})` : ""}
        </div>
      ` : c}
    `;
  }
};
$.styles = Z`
    :host {
      display: inline-block;
      font-family: system-ui, -apple-system, sans-serif;
    }

    :host([disabled]) {
      opacity: 0.6;
      pointer-events: none;
    }

    .select-wrapper {
      position: relative;
      display: inline-block;
      width: 100%;
    }

    select {
      width: 100%;
      padding: 0.5rem 2rem 0.5rem 0.75rem;
      font-size: 0.875rem;
      line-height: 1.25rem;
      border: 1px solid #d1d5db;
      border-radius: 0.375rem;
      background-color: white;
      appearance: none;
      cursor: pointer;
    }

    select:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
    }

    select:disabled {
      background-color: #f3f4f6;
      cursor: not-allowed;
    }

    .chevron {
      position: absolute;
      right: 0.5rem;
      top: 50%;
      transform: translateY(-50%);
      pointer-events: none;
      color: #6b7280;
    }

    .loading {
      color: #9ca3af;
      font-size: 0.875rem;
      padding: 0.5rem 0;
    }

    .error {
      color: #ef4444;
      font-size: 0.75rem;
      padding: 0.25rem 0;
    }

    /* Multiple select styles */
    select[multiple] {
      padding-right: 0.75rem;
      min-height: 120px;
    }

    .selection-count {
      font-size: 0.75rem;
      color: #6b7280;
      margin-top: 0.25rem;
    }
  `;
C([
  p({ type: Boolean })
], $.prototype, "multiple", 2);
C([
  p({ type: Boolean })
], $.prototype, "searchable", 2);
C([
  p({ type: String })
], $.prototype, "placeholder", 2);
C([
  p({ type: String })
], $.prototype, "value", 2);
C([
  p({ type: Array, attribute: "values" })
], $.prototype, "values", 2);
C([
  p({ type: Number, attribute: "max-selections" })
], $.prototype, "maxSelections", 2);
C([
  p({ type: Boolean, attribute: "show-iri" })
], $.prototype, "showIri", 2);
C([
  y()
], $.prototype, "filterText", 2);
$ = C([
  G("prez-vocab-select")
], $);
var tt = Object.defineProperty, st = Object.getOwnPropertyDescriptor, z = /* @__PURE__ */ a((s, e, t, i) => {
  for (var o = i > 1 ? void 0 : i ? st(e, t) : e, r = s.length - 1, n; r >= 0; r--)
    (n = s[r]) && (o = (i ? n(e, t, o) : n(o)) || o);
  return i && o && tt(e, t, o), o;
}, "__decorateClass$2");
let x = class extends m {
  static {
    a(this, "PrezVocabTree");
  }
  constructor() {
    super(...arguments), this.expandAll = !1, this.expandLevel = 1, this.selectable = !0, this.showCount = !1, this.value = null, this.expandedNodes = /* @__PURE__ */ new Set();
  }
  updated(s) {
    super.updated(s), s.has("vocabData") && this.vocabData && this.initializeExpanded();
  }
  initializeExpanded() {
    if (this.vocabData?.tree) {
      if (this.expandAll) {
        const s = /* @__PURE__ */ new Set(), e = /* @__PURE__ */ a((t) => {
          for (const i of t)
            i.children.length > 0 && (s.add(i.iri), e(i.children));
        }, "collectIris");
        e(this.vocabData.tree), this.expandedNodes = s;
      } else if (this.expandLevel > 0) {
        const s = /* @__PURE__ */ new Set(), e = /* @__PURE__ */ a((t, i) => {
          if (!(i <= 0))
            for (const o of t)
              o.children.length > 0 && (s.add(o.iri), e(o.children, i - 1));
        }, "expandToLevel");
        e(this.vocabData.tree, this.expandLevel), this.expandedNodes = s;
      }
    }
  }
  toggleExpand(s, e) {
    e.stopPropagation();
    const t = new Set(this.expandedNodes);
    t.has(s) ? t.delete(s) : t.add(s), this.expandedNodes = t;
  }
  selectNode(s) {
    this.selectable && (this.value = s, this.emitChange(s));
  }
  countDescendants(s) {
    let e = s.children.length;
    for (const t of s.children)
      e += this.countDescendants(t);
    return e;
  }
  renderNode(s) {
    const e = s.children.length > 0, t = this.expandedNodes.has(s.iri), i = this.value === s.iri;
    return l`
      <li class="tree-item">
        <div
          class="tree-row ${i ? "selected" : ""}"
          @click=${() => this.selectNode(s.iri)}
        >
          ${e ? l`
            <button
              class="expand-btn"
              @click=${(o) => this.toggleExpand(s.iri, o)}
              aria-expanded=${t}
              aria-label=${t ? "Collapse" : "Expand"}
            >
              <svg width="12" height="12" viewBox="0 0 12 12" fill="currentColor">
                ${t ? l`<path d="M2 4l4 4 4-4z"/>` : l`<path d="M4 2l4 4-4 4z"/>`}
              </svg>
            </button>
          ` : l`<span class="expand-placeholder"></span>`}
          ${s.notation ? l`<span class="notation">${s.notation}</span>` : c}
          <span class="label">${s.label}</span>
          ${this.showCount && e ? l`
            <span class="count">(${this.countDescendants(s)})</span>
          ` : c}
        </div>
        ${e && t ? l`
          <ul class="children">
            ${s.children.map((o) => this.renderNode(o))}
          </ul>
        ` : c}
      </li>
    `;
  }
  render() {
    if (this.loading)
      return l`<div class="loading">Loading vocabulary...</div>`;
    if (this.error)
      return l`<div class="error">${this.error}</div>`;
    if (!this.vocabData)
      return l`<div class="loading">No vocabulary specified</div>`;
    const s = this.vocabData.tree;
    return !s || s.length === 0 ? l`<div class="empty">No hierarchy available</div>` : l`
      <ul class="tree" role="tree" aria-label=${this.vocabData.label || "Vocabulary tree"}>
        ${s.map((e) => this.renderNode(e))}
      </ul>
    `;
  }
};
x.styles = Z`
    :host {
      display: block;
      font-family: system-ui, -apple-system, sans-serif;
      font-size: 0.875rem;
    }

    :host([disabled]) {
      opacity: 0.6;
      pointer-events: none;
    }

    .tree {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .tree-item {
      padding: 0.125rem 0;
    }

    .tree-row {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
      cursor: pointer;
    }

    .tree-row:hover {
      background-color: #f3f4f6;
    }

    .tree-row.selected {
      background-color: #dbeafe;
    }

    .expand-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 1.25rem;
      height: 1.25rem;
      border: none;
      background: none;
      cursor: pointer;
      color: #6b7280;
      padding: 0;
      flex-shrink: 0;
    }

    .expand-btn:hover {
      color: #374151;
    }

    .expand-placeholder {
      width: 1.25rem;
      height: 1.25rem;
      flex-shrink: 0;
    }

    .label {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .notation {
      color: #6b7280;
      font-size: 0.75rem;
    }

    .count {
      color: #9ca3af;
      font-size: 0.75rem;
    }

    .children {
      list-style: none;
      padding-left: 1.25rem;
      margin: 0;
    }

    .loading {
      color: #9ca3af;
      padding: 0.5rem;
    }

    .error {
      color: #ef4444;
      font-size: 0.75rem;
      padding: 0.25rem;
    }

    .empty {
      color: #9ca3af;
      padding: 0.5rem;
    }
  `;
z([
  p({ type: Boolean, attribute: "expand-all" })
], x.prototype, "expandAll", 2);
z([
  p({ type: Number, attribute: "expand-level" })
], x.prototype, "expandLevel", 2);
z([
  p({ type: Boolean })
], x.prototype, "selectable", 2);
z([
  p({ type: Boolean, attribute: "show-count" })
], x.prototype, "showCount", 2);
z([
  p({ type: String })
], x.prototype, "value", 2);
z([
  y()
], x.prototype, "expandedNodes", 2);
x = z([
  G("prez-vocab-tree")
], x);
var it = Object.defineProperty, ot = Object.getOwnPropertyDescriptor, D = /* @__PURE__ */ a((s, e, t, i) => {
  for (var o = i > 1 ? void 0 : i ? ot(e, t) : e, r = s.length - 1, n; r >= 0; r--)
    (n = s[r]) && (o = (i ? n(e, t, o) : n(o)) || o);
  return i && o && it(e, t, o), o;
}, "__decorateClass$1");
let v = class extends m {
  static {
    a(this, "PrezVocabList");
  }
  constructor() {
    super(...arguments), this.searchable = !0, this.showDefinitions = !1, this.showAltLabels = !1, this.placeholder = "Filter concepts...", this.value = null, this.maxItems = 0, this.filterText = "";
  }
  handleFilter(s) {
    this.filterText = s.target.value;
  }
  selectItem(s) {
    this.value = s.iri, this.emitChange(s.iri);
  }
  get filteredConcepts() {
    if (!this.vocabData?.concepts) return [];
    let s = this.vocabData.concepts;
    if (this.filterText) {
      const e = this.filterText.toLowerCase();
      s = s.filter(
        (t) => t.label.toLowerCase().includes(e) || t.notation?.toLowerCase().includes(e) || t.definition?.toLowerCase().includes(e) || t.altLabels?.some((i) => i.toLowerCase().includes(e))
      );
    }
    return s = [...s].sort((e, t) => e.label.localeCompare(t.label)), this.maxItems > 0 && (s = s.slice(0, this.maxItems)), s;
  }
  render() {
    if (this.loading)
      return l`<div class="loading">Loading vocabulary...</div>`;
    if (this.error)
      return l`<div class="error">${this.error}</div>`;
    if (!this.vocabData)
      return l`<div class="loading">No vocabulary specified</div>`;
    const s = this.filteredConcepts, e = this.vocabData.concepts.length;
    return l`
      ${this.searchable ? l`
        <div class="search">
          <input
            type="text"
            .value=${this.filterText}
            @input=${this.handleFilter}
            placeholder=${this.placeholder}
            aria-label="Filter concepts"
          />
        </div>
      ` : c}

      ${s.length > 0 ? l`
        <ul class="list" role="listbox" aria-label=${this.vocabData.label || "Concepts"}>
          ${s.map((t) => l`
            <li
              class="list-item ${this.value === t.iri ? "selected" : ""}"
              role="option"
              aria-selected=${this.value === t.iri}
              @click=${() => this.selectItem(t)}
            >
              <div class="item-header">
                ${t.notation ? l`
                  <span class="notation">${t.notation}</span>
                ` : c}
                <span class="label">${t.label}</span>
              </div>
              ${this.showDefinitions && t.definition ? l`
                <div class="definition">${t.definition}</div>
              ` : c}
              ${this.showAltLabels && t.altLabels && t.altLabels.length > 0 ? l`
                <div class="alt-labels">Also: ${t.altLabels.join(", ")}</div>
              ` : c}
            </li>
          `)}
        </ul>
        <div class="count">
          ${this.filterText ? `Showing ${s.length} of ${e} concepts` : `${e} concepts`}
        </div>
      ` : l`
        <div class="empty">
          ${this.filterText ? "No matching concepts" : "No concepts available"}
        </div>
      `}
    `;
  }
};
v.styles = Z`
    :host {
      display: block;
      font-family: system-ui, -apple-system, sans-serif;
      font-size: 0.875rem;
    }

    :host([disabled]) {
      opacity: 0.6;
      pointer-events: none;
    }

    .search {
      margin-bottom: 0.5rem;
    }

    .search input {
      width: 100%;
      padding: 0.5rem 0.75rem;
      border: 1px solid #d1d5db;
      border-radius: 0.375rem;
      font-size: 0.875rem;
    }

    .search input:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
    }

    .list {
      list-style: none;
      padding: 0;
      margin: 0;
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #e5e7eb;
      border-radius: 0.375rem;
    }

    .list-item {
      padding: 0.5rem 0.75rem;
      cursor: pointer;
      border-bottom: 1px solid #e5e7eb;
    }

    .list-item:last-child {
      border-bottom: none;
    }

    .list-item:hover {
      background-color: #f9fafb;
    }

    .list-item.selected {
      background-color: #dbeafe;
    }

    .item-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .notation {
      color: #6b7280;
      font-size: 0.75rem;
      font-family: monospace;
    }

    .label {
      font-weight: 500;
    }

    .definition {
      color: #6b7280;
      font-size: 0.75rem;
      margin-top: 0.25rem;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .alt-labels {
      color: #9ca3af;
      font-size: 0.75rem;
      font-style: italic;
    }

    .loading {
      color: #9ca3af;
      padding: 0.5rem;
    }

    .error {
      color: #ef4444;
      font-size: 0.75rem;
      padding: 0.25rem;
    }

    .empty {
      color: #9ca3af;
      padding: 1rem;
      text-align: center;
    }

    .count {
      color: #9ca3af;
      font-size: 0.75rem;
      margin-top: 0.25rem;
    }
  `;
D([
  p({ type: Boolean })
], v.prototype, "searchable", 2);
D([
  p({ type: Boolean, attribute: "show-definitions" })
], v.prototype, "showDefinitions", 2);
D([
  p({ type: Boolean, attribute: "show-alt-labels" })
], v.prototype, "showAltLabels", 2);
D([
  p({ type: String })
], v.prototype, "placeholder", 2);
D([
  p({ type: String })
], v.prototype, "value", 2);
D([
  p({ type: Number, attribute: "max-items" })
], v.prototype, "maxItems", 2);
D([
  y()
], v.prototype, "filterText", 2);
v = D([
  G("prez-vocab-list")
], v);
var rt = Object.defineProperty, nt = Object.getOwnPropertyDescriptor, w = /* @__PURE__ */ a((s, e, t, i) => {
  for (var o = i > 1 ? void 0 : i ? nt(e, t) : e, r = s.length - 1, n; r >= 0; r--)
    (n = s[r]) && (o = (i ? n(e, t, o) : n(o)) || o);
  return i && o && rt(e, t, o), o;
}, "__decorateClass");
let g = class extends m {
  static {
    a(this, "PrezVocabAutocomplete");
  }
  constructor() {
    super(...arguments), this.placeholder = "Type to search...", this.value = null, this.minChars = 1, this.maxSuggestions = 10, this.showDefinitions = !1, this.inputText = "", this.showDropdown = !1, this.highlightedIndex = -1;
  }
  get suggestions() {
    if (!this.vocabData?.concepts || this.inputText.length < this.minChars)
      return [];
    const s = this.inputText.toLowerCase();
    return this.vocabData.concepts.filter(
      (t) => t.label.toLowerCase().includes(s) || t.notation?.toLowerCase().includes(s) || t.altLabels?.some((i) => i.toLowerCase().includes(s))
    ).sort((t, i) => {
      const o = t.label.toLowerCase().startsWith(s) ? 0 : 1, r = i.label.toLowerCase().startsWith(s) ? 0 : 1;
      return o !== r ? o - r : t.label.localeCompare(i.label);
    }).slice(0, this.maxSuggestions);
  }
  updated(s) {
    if (super.updated(s), s.has("value") && this.value) {
      const e = this.conceptMap.get(this.value);
      e && (this.inputText = e.label);
    }
  }
  handleInput(s) {
    if (this.inputText = s.target.value, this.showDropdown = !0, this.highlightedIndex = -1, this.value) {
      const e = this.conceptMap.get(this.value);
      e && this.inputText !== e.label && (this.value = null, this.emitChange(""));
    }
  }
  handleFocus() {
    this.inputText.length >= this.minChars && (this.showDropdown = !0);
  }
  handleBlur() {
    setTimeout(() => {
      this.showDropdown = !1;
    }, 200);
  }
  handleKeydown(s) {
    const e = this.suggestions;
    switch (s.key) {
      case "ArrowDown":
        s.preventDefault(), this.highlightedIndex = Math.min(this.highlightedIndex + 1, e.length - 1);
        break;
      case "ArrowUp":
        s.preventDefault(), this.highlightedIndex = Math.max(this.highlightedIndex - 1, -1);
        break;
      case "Enter":
        s.preventDefault(), this.highlightedIndex >= 0 && e[this.highlightedIndex] && this.selectConcept(e[this.highlightedIndex]);
        break;
      case "Escape":
        this.showDropdown = !1, this.inputEl?.blur();
        break;
    }
  }
  selectConcept(s) {
    this.value = s.iri, this.inputText = s.label, this.showDropdown = !1, this.highlightedIndex = -1, this.emitChange(s.iri);
  }
  clear() {
    this.value = null, this.inputText = "", this.showDropdown = !1, this.highlightedIndex = -1, this.emitChange(""), this.inputEl?.focus();
  }
  render() {
    if (this.error)
      return l`<div class="error">${this.error}</div>`;
    const s = this.suggestions;
    return l`
      <div class="input-wrapper">
        <input
          type="text"
          .value=${this.inputText}
          placeholder=${this.loading ? "Loading..." : this.placeholder}
          ?disabled=${this.disabled || this.loading}
          @input=${this.handleInput}
          @focus=${this.handleFocus}
          @blur=${this.handleBlur}
          @keydown=${this.handleKeydown}
          aria-label=${this.vocabData?.label || "Concept search"}
          aria-autocomplete="list"
          aria-expanded=${this.showDropdown}
          role="combobox"
        />
        ${this.inputText ? l`
          <button
            class="clear-btn"
            @mousedown=${(e) => e.preventDefault()}
            @click=${this.clear}
            aria-label="Clear"
          >
            <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
              <path d="M4.28 3.22a.75.75 0 00-1.06 1.06L6.94 8l-3.72 3.72a.75.75 0 101.06 1.06L8 9.06l3.72 3.72a.75.75 0 101.06-1.06L9.06 8l3.72-3.72a.75.75 0 00-1.06-1.06L8 6.94 4.28 3.22z"/>
            </svg>
          </button>
        ` : c}
      </div>

      ${this.showDropdown && this.vocabData ? l`
        <div class="dropdown" role="listbox">
          ${this.loading ? l`
            <div class="loading">Loading...</div>
          ` : s.length > 0 ? s.map((e, t) => l`
            <div
              class="dropdown-item ${t === this.highlightedIndex ? "highlighted" : ""} ${this.value === e.iri ? "selected" : ""}"
              role="option"
              aria-selected=${this.value === e.iri}
              @mousedown=${(i) => i.preventDefault()}
              @click=${() => this.selectConcept(e)}
            >
              <div class="item-header">
                ${e.notation ? l`
                  <span class="notation">${e.notation}</span>
                ` : c}
                <span class="label">${e.label}</span>
              </div>
              ${this.showDefinitions && e.definition ? l`
                <div class="definition">${e.definition}</div>
              ` : c}
            </div>
          `) : this.inputText.length >= this.minChars ? l`
            <div class="no-results">No matching concepts</div>
          ` : c}
        </div>
      ` : c}
    `;
  }
};
g.styles = Z`
    :host {
      display: inline-block;
      font-family: system-ui, -apple-system, sans-serif;
      position: relative;
    }

    :host([disabled]) {
      opacity: 0.6;
      pointer-events: none;
    }

    .input-wrapper {
      position: relative;
      width: 100%;
    }

    input {
      width: 100%;
      padding: 0.5rem 2rem 0.5rem 0.75rem;
      font-size: 0.875rem;
      line-height: 1.25rem;
      border: 1px solid #d1d5db;
      border-radius: 0.375rem;
      background-color: white;
      box-sizing: border-box;
    }

    input:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
    }

    input:disabled {
      background-color: #f3f4f6;
      cursor: not-allowed;
    }

    .clear-btn {
      position: absolute;
      right: 0.5rem;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      cursor: pointer;
      color: #9ca3af;
      padding: 0.125rem;
      line-height: 0;
    }

    .clear-btn:hover {
      color: #6b7280;
    }

    .dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      margin-top: 0.25rem;
      background: white;
      border: 1px solid #e5e7eb;
      border-radius: 0.375rem;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      max-height: 240px;
      overflow-y: auto;
      z-index: 50;
    }

    .dropdown-item {
      padding: 0.5rem 0.75rem;
      cursor: pointer;
    }

    .dropdown-item:hover,
    .dropdown-item.highlighted {
      background-color: #f3f4f6;
    }

    .dropdown-item.selected {
      background-color: #dbeafe;
    }

    .item-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .notation {
      color: #6b7280;
      font-size: 0.75rem;
      font-family: monospace;
    }

    .label {
      font-weight: 500;
      font-size: 0.875rem;
    }

    .definition {
      color: #6b7280;
      font-size: 0.75rem;
      margin-top: 0.125rem;
      display: -webkit-box;
      -webkit-line-clamp: 1;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .no-results {
      padding: 0.75rem;
      color: #9ca3af;
      text-align: center;
      font-size: 0.875rem;
    }

    .loading {
      padding: 0.75rem;
      color: #9ca3af;
      text-align: center;
      font-size: 0.875rem;
    }

    .error {
      color: #ef4444;
      font-size: 0.75rem;
      padding: 0.25rem 0;
    }
  `;
w([
  p({ type: String })
], g.prototype, "placeholder", 2);
w([
  p({ type: String })
], g.prototype, "value", 2);
w([
  p({ type: Number, attribute: "min-chars" })
], g.prototype, "minChars", 2);
w([
  p({ type: Number, attribute: "max-suggestions" })
], g.prototype, "maxSuggestions", 2);
w([
  p({ type: Boolean, attribute: "show-definitions" })
], g.prototype, "showDefinitions", 2);
w([
  y()
], g.prototype, "inputText", 2);
w([
  y()
], g.prototype, "showDropdown", 2);
w([
  y()
], g.prototype, "highlightedIndex", 2);
w([
  Ke("input")
], g.prototype, "inputEl", 2);
g = w([
  G("prez-vocab-autocomplete")
], g);
export {
  g as PrezVocabAutocomplete,
  m as PrezVocabBase,
  v as PrezVocabList,
  $ as PrezVocabSelect,
  x as PrezVocabTree,
  ct as clearCache,
  Ye as detectBaseUrl,
  Je as fetchVocab,
  Ge as resolveVocabUrl
};
